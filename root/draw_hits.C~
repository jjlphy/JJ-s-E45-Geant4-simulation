// draw_hits.C (최종 버전)

#include <TFile.h>
#include <TTree.h>
#include <TH2F.h>
#include <TCanvas.h>
#include <TBox.h>
#include <iostream>

void draw_hits(const TString& root_file_name) {
    TFile *f = new TFile(root_file_name);
    if (!f || f->IsZombie()) {
        std::cerr << "Error: Cannot open file '" << root_file_name << "'" << std::endl;
        return;
    }

    TTree *tree = (TTree*)f->Get("g4hyptpc");
    if (!tree) {
        std::cerr << "Error: Cannot find TTree 'g4hyptpc'." << std::endl;
        return;
    }

    // 1. 히스토그램들을 먼저 정의합니다. (이전과 동일)
    TH2F *h_bvh_u = new TH2F("h_bvh_u", "BVH_U Hits (Y vs X);X [mm];Y [mm]", 100, -15, 15, 100, -40, 40);
    TH2F *h_bvh_d = new TH2F("h_bvh_d", "BVH_D Hits (Y vs X);X [mm];Y [mm]", 100, -15, 15, 150, -80, 80);
    TH2F *h_t0    = new TH2F("h_t0", "T0 Hits (Y vs X);X [mm];Y [mm]", 100, -25, 25, 200, -90, 90);
    TH2F *h_bh2   = new TH2F("h_bh2", "BH2 Hits (Y vs X);X [mm];Y [mm]", 200, -100, 100, 200, -60, 60);

    // 2. 이벤트 루프 대신 TTree::Draw를 사용해 히스토그램을 채웁니다.
    // TParticle 객체의 멤버 변수인 fVx, fVy에 직접 접근합니다.
    // ">>+ hist_name"은 결과를 기존 히스토그램에 추가하라는 의미입니다.
    // "goff" 옵션은 이 과정에서 불필요한 그림이 그려지는 것을 방지합니다.
    tree->Draw("BH2.fVy:BH2.fVx >>+ h_bh2", "", "goff");
    tree->Draw("T0.fVy:T0.fVx >>+ h_t0", "", "goff");
    tree->Draw("BVH_U.fVy:BVH_U.fVx >>+ h_bvh_u", "", "goff");
    tree->Draw("BVH_D.fVy:BVH_D.fVx >>+ h_bvh_d", "", "goff");

    // 3. Canvas 생성 및 결과 그리기 (이전과 동일)
    TCanvas *c1 = new TCanvas("c1", "Detector Hits with Geometry", 1600, 1200);
    c1->Divide(2, 2);
    
    TBox box;
    box.SetFillStyle(0);
    box.SetLineColor(kRed);
    box.SetLineWidth(2);
    
    c1->cd(1);
    h_bh2->Draw("colz");
    double bh2_seg_x = 14.0, bh2_seg_y = 100.0, bh2_center_x = -14.0, bh2_w0 = 4.5;
    for (int i = 0; i < 12; ++i) {
        double seg_center_x = bh2_center_x + (i + 1 - bh2_w0) * bh2_seg_x;
        box.DrawBox(seg_center_x - bh2_seg_x / 2.0, -bh2_seg_y / 2.0, seg_center_x + bh2_seg_x / 2.0, bh2_seg_y / 2.0);
    }
    
    c1->cd(2);
    h_t0->Draw("colz");
    double t0_total_x = 32.0, t0_total_y = 160.0;
    double t0_seg_height = t0_total_y / 5.0;
    for (int i = 0; i < 5; ++i) {
        box.DrawBox(-t0_total_x / 2.0, -t0_total_y / 2.0 + i * t0_seg_height, t0_total_x / 2.0, -t0_total_y / 2.0 + (i+1) * t0_seg_height);
    }

    c1->cd(3);
    h_bvh_u->Draw("colz");
    double bvh_u_total_x = 10.0, bvh_u_total_y = 60.0;
    double bvh_u_seg_width = bvh_u_total_x / 10.0;
    for (int i = 0; i < 10; ++i) {
        box.DrawBox(-bvh_u_total_x / 2.0 + i * bvh_u_seg_width, -bvh_u_total_y / 2.0, -bvh_u_total_x / 2.0 + (i+1) * bvh_u_seg_width, bvh_u_total_y / 2.0);
    }
    
    c1->cd(4);
    h_bvh_d->Draw("colz");
    double bvh_d_total_x = 2.0, bvh_d_total_y = 140.0;
    double bvh_d_seg_width = bvh_d_total_x / 60.0;
    for (int i = 0; i < 60; ++i) {
        box.DrawBox(-bvh_d_total_x / 2.0 + i * bvh_d_seg_width, -bvh_d_total_y / 2.0, -bvh_d_total_x / 2.0 + (i+1) * bvh_d_seg_width, bvh_d_total_y / 2.0);
    }
}

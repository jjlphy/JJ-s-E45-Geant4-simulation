#include <TFile.h>
#include <TTree.h>
#include <TH2F.h>
#include <TCanvas.h>
#include <TParticle.h>
#include <TLine.h> // 선을 그리기 위해 추가
#include <vector>
#include <iostream>

void plot_bvh_d() {
    TFile *f = gFile;
    if (!f || f->IsZombie()) {
        std::cout << "오류: ROOT 파일이 열려있지 않습니다." << std::endl;
        return;
    }

    TTree *tree = (TTree*)f->Get("g4hyptpc");
    if (!tree) {
        std::cout << "오류: TTree 'g4hyptpc'를 찾을 수 없습니다." << std::endl;
        return;
    }

    // ## 변경점 1: 히스토그램을 물리적 크기에 맞게 생성 ##
    // 전체 폭: 60개 * 10mm = 600mm. 중앙을 0으로 두면 -300mm ~ +300mm
    // 전체 높이: 140mm. 중앙을 0으로 두면 -70mm ~ +70mm
    // 이름, 제목, x축(bins, min, max), y축(bins, min, max)
    TH2F *h_hitmap_xy = new TH2F("h_hitmap_xy", "BVH_D Hit Distribution;X [mm];Y [mm];Hits",
                                600, -300.0, 300.0,  // x축: -300mm ~ 300mm, 1mm 간격
                                140, -70.0, 70.0);   // y축: -70mm ~ 70mm, 1mm 간격

    std::vector<TParticle> *bvh_hits = nullptr;
    tree->SetBranchAddress("BVH_D", &bvh_hits);

    Long64_t nEntries = tree->GetEntries();
    std::cout << "총 " << nEntries << "개의 이벤트를 처리합니다..." << std::endl;

    for (Long64_t i = 0; i < nEntries; ++i) {
        tree->GetEntry(i);

        for (const TParticle& particle : *bvh_hits) {
            // ## 변경점 2: TParticle에서 직접 물리 좌표(x, y)를 읽어옴 ##
            // Vx()와 Vy()는 입자가 생성된(여기서는 검출기에 hit한) x, y 좌표를 반환합니다.
            double hit_x = particle.Vx();
            double hit_y = particle.Vy();

            // 읽어온 좌표로 히스토그램을 채웁니다.
            h_hitmap_xy->Fill(hit_x, hit_y);
        }
    }
    std::cout << "이벤트 처리 완료!" << std::endl;

    TCanvas *c1 = new TCanvas("c1", "BVH_D Physical Hit Map", 900, 500);
    c1->cd();
    h_hitmap_xy->SetStats(0);
    h_hitmap_xy->Draw("COLZ");

    // ## 추가: 신틸레이터 경계선 그리기 ##
    // 60개의 세그먼트는 61개의 경계선을 가집니다.
    for (int i = 0; i <= 60; ++i) {
        double x_pos = -300.0 + (i * 10.0); // -300, -290, -280, ..., +300
        // TLine(x1, y1, x2, y2)
        TLine *line = new TLine(x_pos, -70.0, x_pos, 70.0);
        line->SetLineColor(kRed); // 선 색깔을 빨간색으로
        line->SetLineStyle(1);    // 실선
        line->Draw("SAME");       // "SAME" 옵션으로 기존 히스토그램 위에 겹쳐서 그림
    }
    
    // 바깥쪽 테두리선 그리기
    TLine* box_top = new TLine(-300.0, 70.0, 300.0, 70.0);
    TLine* box_bottom = new TLine(-300.0, -70.0, 300.0, -70.0);
    box_top->SetLineColor(kRed);
    box_bottom->SetLineColor(kRed);
    box_top->Draw("SAME");
    box_bottom->Draw("SAME");
}
